////////////////////////////////////////////////////////////////////////
// Class:       MyPandoraAnalyzer
// Module Type: analyzer
// File:        MyPandoraAnalyzer_module.cc
//
// Generated at Thu Jun 23 00:24:52 2016 by Lorena Escudero Sanchez using artmod
// from cetpkgsupport v1_10_02.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "lardata/RecoBase/PFParticle.h"
#include "lardata/RecoBase/Vertex.h"
#include "lardata/RecoBase/Track.h"
#include "lardata/RecoBase/Cluster.h"
#include "lardata/RecoBase/Hit.h"
#include "SimulationBase/MCTruth.h"
#include "SimulationBase/MCParticle.h"

#include "larpandora/LArPandoraInterface/LArPandoraHelper.h"


namespace nmspc {
  class MyPandoraAnalyzer;
}

class nmspc::MyPandoraAnalyzer : public art::EDAnalyzer {
public:
  explicit MyPandoraAnalyzer(fhicl::ParameterSet const & pset);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  MyPandoraAnalyzer(MyPandoraAnalyzer const &) = delete;
  MyPandoraAnalyzer(MyPandoraAnalyzer &&) = delete;
  MyPandoraAnalyzer & operator = (MyPandoraAnalyzer const &) = delete;
  MyPandoraAnalyzer & operator = (MyPandoraAnalyzer &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;
  void reconfigure(fhicl::ParameterSet const &pset) override;

private:

  /**                                                                                                                                                 
   *  @brief Count the number of reconstructed hits in a given wire plane                                                                             
   *                                                                                                                                                  
   *  @param view the wire plane ID                                                                                                                   
   *  @param hitVector the input vector of reconstructed hits                                                                                         
   */
  int CountHitsByType(const int view, const lar_pandora::HitVector &hitVector) const;


  bool NumberRecoHits(const art::Ptr<recob::PFParticle> particle, const lar_pandora::PFParticlesToClusters pfParticleToClusterMap,
                      const lar_pandora::ClustersToHits clustersToHits) const;

  unsigned int NumberClusters(const art::Ptr<recob::PFParticle> particle,
                              const lar_pandora::PFParticlesToClusters pfParticleToClusterMap) const;

  void GetRecoToTrueMatches(const lar_pandora::PFParticlesToHits &recoParticlesToHits, 
			    const lar_pandora::HitsToMCParticles &trueHitsToParticles,
			    lar_pandora::MCParticlesToPFParticles &matchedParticles, 
			    lar_pandora::MCParticlesToHits &matchedHits) const;

  void PrintMatchingHits(const art::Ptr<recob::PFParticle> particle, const lar_pandora::PFParticlesToHits &recoParticlesToHits, 
			 const lar_pandora::MCParticlesToHits trueParticlesToHits, lar_pandora::MCParticlesToPFParticles &matchedParticles, 
			 lar_pandora::MCParticlesToHits &matchedHits) const;
  
  std::string  m_hitfinderLabel;         ///<
  std::string  m_spacepointLabel;        ///< 
  std::string  m_particleLabel;          ///<
  std::string  m_geantModuleLabel;       ///<

  bool         m_useDaughterPFParticles; ///<                                                                                                        
  bool         m_useDaughterMCParticles; ///<                                                                                                        
  bool         m_addDaughterPFParticles; ///<                                                                                                        
  bool         m_addDaughterMCParticles; ///<                                                                                                        
  bool         m_printDebug;             ///< switch for print statements (TODO: use message service!)   

};


nmspc::MyPandoraAnalyzer::MyPandoraAnalyzer(fhicl::ParameterSet const & pset)
  :
  EDAnalyzer(pset)  // ,
 // More initializers here.
{
  this->reconfigure(pset);
}

void nmspc::MyPandoraAnalyzer::analyze(art::Event const & evt)
{

  // Collect Hits                                                                                                                                     
  // ============                                                                                                                                     
  lar_pandora::HitVector hitVector;
  lar_pandora::LArPandoraHelper::CollectHits(evt, m_hitfinderLabel, hitVector);

  if (m_printDebug)
    std::cout << "  Total hits: " << hitVector.size() << std::endl;

  // Collect Clusters
  // ================  
  lar_pandora::ClusterVector clusterVector; //vector of clusters  
  lar_pandora::ClustersToHits clustersToHits;//Clusters-to-Hits map 
  lar_pandora::LArPandoraHelper::CollectClusters(evt, m_spacepointLabel, clusterVector, clustersToHits);//map Clusters-to-hits 

  // Collect PFParticles and match to clusters
  // =========================================
  lar_pandora::PFParticleVector pfParticleList; //vector of PFParticles   
  lar_pandora::PFParticlesToClusters pfParticleToClusterMap; //PFParticle-to-cluster map 
  lar_pandora::LArPandoraHelper::CollectPFParticles(evt, m_particleLabel, pfParticleList, pfParticleToClusterMap);
                                 //collect PFParticles and build map PFParticles to Clusters       

  
  // Collect PFParticles and match Reco Particles to Hits                                                                                             
  // ====================================================                                                                                             
  lar_pandora::PFParticleVector recoParticleVector;
  lar_pandora::PFParticlesToHits recoParticlesToHits;
  lar_pandora::HitsToPFParticles recoHitsToParticles;

  lar_pandora::LArPandoraHelper::CollectPFParticles(evt, m_particleLabel, recoParticleVector);
  lar_pandora::LArPandoraHelper::BuildPFParticleHitMaps(evt, m_particleLabel, m_spacepointLabel, recoParticlesToHits, recoHitsToParticles,
							(m_useDaughterPFParticles ? (m_addDaughterPFParticles ? lar_pandora::LArPandoraHelper::kAddDaughters : lar_pandora::LArPandoraHelper::kUseDaughters) : lar_pandora::LArPandoraHelper::kIgnoreDaughters));

  if (m_printDebug)
    std::cout << "  RecoParticles: " << recoParticleVector.size() << std::endl;
  

  // Collect MCParticles and match True Particles to Hits                                                                                             
  // ====================================================                                                                                             
  lar_pandora::MCParticleVector trueParticleVector;
  lar_pandora::MCTruthToMCParticles truthToParticles;
  lar_pandora::MCParticlesToMCTruth particlesToTruth;
  lar_pandora::MCParticlesToHits trueParticlesToHits;
  lar_pandora::HitsToMCParticles trueHitsToParticles;

  lar_pandora::LArPandoraHelper::CollectMCParticles(evt, m_geantModuleLabel, trueParticleVector);
  lar_pandora::LArPandoraHelper::CollectMCParticles(evt, m_geantModuleLabel, truthToParticles, particlesToTruth);
  lar_pandora::LArPandoraHelper::BuildMCParticleHitMaps(evt, m_geantModuleLabel, hitVector, trueParticlesToHits, trueHitsToParticles,
							(m_useDaughterMCParticles ? (m_addDaughterMCParticles ? lar_pandora::LArPandoraHelper::kAddDaughters : lar_pandora::LArPandoraHelper::kUseDaughters) : lar_pandora::LArPandoraHelper::kIgnoreDaughters));

  if (m_printDebug)
    std::cout << "  TrueParticles: " << particlesToTruth.size() << std::endl;


  // Match Reco Particles to True Particles                                                                                                           
  // ======================================                                                                                                           
  lar_pandora::MCParticlesToPFParticles matchedParticles;
  lar_pandora::MCParticlesToHits matchedParticleHits;
  this->GetRecoToTrueMatches(recoParticlesToHits, trueHitsToParticles, matchedParticles, matchedParticleHits);
  
  // ************ USE INFORMATION ***************                                                                                                 
  
  //loop to get information from the list of PFParticles                                                                                          
  for (unsigned int n = 0; n < pfParticleList.size(); ++n)
    {
      const art::Ptr<recob::PFParticle> particle = pfParticleList.at(n);
      
      std::cout <<"PFParticle: " << particle->Self()
                << " IsPrimary? " << particle->IsPrimary()
                << " IsNeutrino? " << lar_pandora::LArPandoraHelper::IsNeutrino(particle)
                << " IsTrack? " << lar_pandora::LArPandoraHelper::IsTrack(particle)
                << " IsShower? " << lar_pandora::LArPandoraHelper::IsShower(particle)
		<< std::endl;
      
    }

  //loop to get information about the daughters of the neutrino                                                                                
  for (unsigned int n = 0; n < pfParticleList.size(); ++n)
    {
      const art::Ptr<recob::PFParticle> particle = pfParticleList.at(n);

      if(lar_pandora::LArPandoraHelper::IsNeutrino(particle))
        {
          const std::vector<size_t> &daughterIDs = particle->Daughters();
	  std::cout << "Neutrino has ID: " << pfParticleList.at(n)->Self()
                    << " and " << daughterIDs.size() << " daughters" << std::endl;

          for (unsigned int m = 0; m < daughterIDs.size(); ++m)
            {
              const art::Ptr<recob::PFParticle> daughter = pfParticleList.at(daughterIDs.at(m));

	      std::cout << "Neutrino daughter ID: " << daughterIDs[m]
			<< " IsTrack? " << lar_pandora::LArPandoraHelper::IsTrack(daughter)
			<< " IsShower? " << lar_pandora::LArPandoraHelper::IsShower(daughter)
                        << std::endl;
            }
        }
    }


  // First we are going to find the neutrino with more daughters in the event (in case there is more than one neutrino reconstructed)            
  size_t nuID = -std::numeric_limits<std::size_t>::max();
  bool found_neutrino = false;
  unsigned int n_daughters = 0;

  for (unsigned int n = 0; n < pfParticleList.size(); ++n)
    {
      const art::Ptr<recob::PFParticle> particle = pfParticleList.at(n);

      if(lar_pandora::LArPandoraHelper::IsNeutrino(particle))
        {
          const std::vector<size_t> &daughterIDs = particle->Daughters();
          if(daughterIDs.size() > n_daughters)
            {
              n_daughters = daughterIDs.size();
              found_neutrino = true;
              nuID = n;
            }
        }
    }//at the end, nuID is the index of the PFParticle     
  //corresponding to the neutrino with more daughters       

  if(found_neutrino)
    {
      //Now we can start directly with the neutrino PFParticle                                                                                          
      const art::Ptr<recob::PFParticle> neutrino = pfParticleList.at(nuID);
      const std::vector<size_t> &daughterIDs = neutrino->Daughters();
      for (unsigned int m = 0; m < daughterIDs.size(); ++m)
        {
          const art::Ptr<recob::PFParticle> daughter = pfParticleList.at(daughterIDs[m]);
          unsigned int n_clusters = this->NumberClusters(daughter,pfParticleToClusterMap);
          if(n_clusters==3)
            {
              if(this->NumberRecoHits(daughter,pfParticleToClusterMap,clustersToHits))
                {
		  this->PrintMatchingHits(daughter, recoParticlesToHits, trueParticlesToHits, matchedParticles, matchedParticleHits);
                }
            }

        }//daughters                                                                                                                            
    }//found neutrino                                                                                                                           
        

}


 //------------------------------------------------------------------------------------------------------------------------------------ 
void nmspc::MyPandoraAnalyzer::reconfigure(fhicl::ParameterSet const & pset)
{
  m_particleLabel = pset.get<std::string>("PFParticleModule","pandoraNu");
  m_hitfinderLabel = pset.get<std::string>("HitFinderModule","gaushit");
  m_geantModuleLabel = pset.get<std::string>("GeantModule","largeant");
  m_spacepointLabel = pset.get<std::string>("SpacePointModule","pandoraNu");

  m_useDaughterPFParticles = pset.get<bool>("UseDaughterPFParticles",false);
  m_useDaughterMCParticles = pset.get<bool>("UseDaughterMCParticles",true);
  m_addDaughterPFParticles = pset.get<bool>("AddDaughterPFParticles",true);
  m_addDaughterMCParticles = pset.get<bool>("AddDaughterMCParticles",true);
  m_printDebug = pset.get<bool>("PrintDebug",true);

}

//------------------------------------------------------------------------------------------------------------------------------------------           

int nmspc::MyPandoraAnalyzer::CountHitsByType(const int view, const lar_pandora::HitVector &hitVector) const
{
  int nHits(0);

  for (lar_pandora::HitVector::const_iterator iter = hitVector.begin(), iterEnd = hitVector.end(); iter != iterEnd; ++iter)
    {
      const art::Ptr<recob::Hit> hit = *iter;
      if (hit->View() == view)
	++nHits;
    }

  return nHits;
}

//------------------------------------------------------------------------------------------------------------------------------------------        

void nmspc::MyPandoraAnalyzer::GetRecoToTrueMatches(const lar_pandora::PFParticlesToHits &recoParticlesToHits, const lar_pandora::HitsToMCParticles &trueHitsToParticles, lar_pandora::MCParticlesToPFParticles &matchedParticles, lar_pandora::MCParticlesToHits &matchedHits) const
{
  bool foundMatches(false);

  for (lar_pandora::PFParticlesToHits::const_iterator iter1 = recoParticlesToHits.begin(), iterEnd1 = recoParticlesToHits.end();
       iter1 != iterEnd1; ++iter1)
    {
      const art::Ptr<recob::PFParticle> recoParticle = iter1->first;

      const lar_pandora::HitVector &hitVector = iter1->second;

      lar_pandora::MCParticlesToHits truthContributionMap;
      
      for (lar_pandora::HitVector::const_iterator iter2 = hitVector.begin(), iterEnd2 = hitVector.end(); iter2 != iterEnd2; ++iter2)
        {
	  const art::Ptr<recob::Hit> hit = *iter2;
	  //Lorena: in the workshop we will use v5_8 reco files in LArSoft v5_13, it gives problems in trueHitsToParticles.find(hit)
	  const double recoHitTime(hit->PeakTime());                                                                                                
          const geo::WireID recoHitWire(hit->WireID()); 
	  
	  lar_pandora::HitsToMCParticles::const_iterator iter3 = trueHitsToParticles.end();
	  for (lar_pandora::HitsToMCParticles::const_iterator iter4 = trueHitsToParticles.begin(), iterEnd4 = trueHitsToParticles.end();
	       iter4 != iterEnd4; ++iter4)
	    {
	      
	      const art::Ptr<recob::Hit> trueHit = iter4->first;
	      const double trueHitTime(trueHit->PeakTime());
	      const geo::WireID trueHitWire(trueHit->WireID());
	      if( (trueHitTime==recoHitTime) &&
		  (trueHitWire==recoHitWire) )
		iter3 = trueHitsToParticles.find(trueHit);
	      
	    }

	  if (trueHitsToParticles.end() == iter3)
	    continue;
	    
	  const art::Ptr<simb::MCParticle> trueParticle = iter3->second;

	  truthContributionMap[trueParticle].push_back(hit);
        }

      lar_pandora::MCParticlesToHits::const_iterator mIter = truthContributionMap.end();

      for (lar_pandora::MCParticlesToHits::const_iterator iter5 = truthContributionMap.begin(), iterEnd5 = truthContributionMap.end();
	   iter5 != iterEnd5; ++iter5)
	{
	  if ((truthContributionMap.end() == mIter) || (iter5->second.size() > mIter->second.size()))
            {
	      mIter = iter5;
            }
        }

      if (truthContributionMap.end() != mIter)
        {
	  const art::Ptr<simb::MCParticle> trueParticle = mIter->first;

	  lar_pandora::MCParticlesToHits::const_iterator iter6 = matchedHits.find(trueParticle);

	  if ((matchedHits.end() == iter6) || (mIter->second.size() > iter6->second.size()))
            {
	      matchedParticles[trueParticle] = recoParticle;
	      matchedHits[trueParticle] = mIter->second;
	      foundMatches = true;
            }
        }
    }

  if (!foundMatches)
    return;

}

//------------------------------------------------------------------------------------------------------------------------------------------        

unsigned int nmspc::MyPandoraAnalyzer::NumberClusters(const art::Ptr<recob::PFParticle> particle, const lar_pandora::PFParticlesToClusters pfParticleToClusterMap) const
{
  unsigned int n_clusters = 0;
  lar_pandora::PFParticlesToClusters::const_iterator clusterMapIter = pfParticleToClusterMap.find(particle);//find clusters                      
  if (clusterMapIter != pfParticleToClusterMap.end())
    {
      const lar_pandora::ClusterVector & clusters = clusterMapIter->second;
      if(clusters.size()>3)
	std::cerr << "Daughter has more than three clusters!" << std::endl;
      //check there are no more than one cluster in each plane                                                                                   
      for(unsigned int k = 0; k<3; k++)
        {
          int n_clusters_view = 0;
          for(unsigned int l = 0; l < clusters.size(); ++l)
            {
              if(clusters[l]->Plane().Plane==k)
                n_clusters_view++;
            }
          if(n_clusters_view>1)
	    std::cerr << "Daughter has more than one cluster in one plane!" << std::endl;
        }
      n_clusters = clusters.size();
    }

  return n_clusters;
}

//------------------------------------------------------------------------------------------------------------------------------------------       
     
bool nmspc::MyPandoraAnalyzer::NumberRecoHits(const art::Ptr<recob::PFParticle> particle,const lar_pandora::PFParticlesToClusters pfParticleToClusterMap, const lar_pandora::ClustersToHits clustersToHits) const
{
  double hits[3] = {0.0,0.0,0.0};
  lar_pandora::PFParticlesToClusters::const_iterator clusterMapIter = pfParticleToClusterMap.find(particle);//find clusters                       
  if (clusterMapIter != pfParticleToClusterMap.end())
    {
      const lar_pandora::ClusterVector & clusters = clusterMapIter->second;
      for(unsigned int l = 0; l < clusters.size(); ++l)
        {
          int index = clusters[l]->Plane().Plane;
	  lar_pandora::ClustersToHits::const_iterator clustersHitsMapIter = clustersToHits.find(clusters[l]);
          if(clustersHitsMapIter != clustersToHits.end())
            {
              const lar_pandora::HitVector hitvec = clustersHitsMapIter->second;
              hits[index]=hitvec.size();
	    }
        }
    }

  return ((hits[0]>30)&&(hits[1]>30)&&(hits[2]>30));
}

//------------------------------------------------------------------------------------------------------------------------------------------      

void nmspc::MyPandoraAnalyzer::PrintMatchingHits(const art::Ptr<recob::PFParticle> particle, const lar_pandora::PFParticlesToHits &recoParticlesToHits, const lar_pandora::MCParticlesToHits trueParticlesToHits, lar_pandora::MCParticlesToPFParticles &matchedParticles, lar_pandora::MCParticlesToHits &matchedParticleHits) const
{

  lar_pandora::PFParticlesToHits::const_iterator pIter = recoParticlesToHits.find(particle);
  const lar_pandora::HitVector &recoHitVector = pIter->second;
  std::cout << "Daughter particle ID : " << particle->Self() << std::endl;
  std::cout << "     - Hits: " << recoHitVector.size()
	    << " (" << this->CountHitsByType(geo::kU,recoHitVector)
	    << " , " << this->CountHitsByType(geo::kV,recoHitVector)
	    << " , " << this->CountHitsByType(geo::kW,recoHitVector)
	    << ")" << std::endl;
  
  for (lar_pandora::MCParticlesToHits::const_iterator iter = trueParticlesToHits.begin(), iterEnd = trueParticlesToHits.end(); iter != iterEnd; ++iter)
    {                                                                                                                                          
      const art::Ptr<simb::MCParticle> trueParticle = iter->first;                                                                               
      const lar_pandora::HitVector &trueHitVector = iter->second;                                                                                
      lar_pandora::MCParticlesToPFParticles::const_iterator pIter1 = matchedParticles.find(trueParticle);                                          
      
      if (matchedParticles.end() != pIter1)                                                                                                      
        {                                                                                                                                       
          const art::Ptr<recob::PFParticle> recoParticle = pIter1->second;                                                                      
	  if(recoParticle==particle)
	    {  

	      lar_pandora::MCParticlesToHits::const_iterator pIter2 = matchedParticleHits.find(trueParticle);                                       
	      const lar_pandora::HitVector &matchedHitVector = pIter2->second;                                                                        
	      
	      std::cout << "     - Matches MC particle with PDG code : " << trueParticle->PdgCode() << " (" << trueHitVector.size() << " hits)" << std::endl;
	      std::cout << "                matched hits = " << matchedHitVector.size() 
			<< " (" << this->CountHitsByType(geo::kU,matchedHitVector)
			<< " , " << this->CountHitsByType(geo::kV,matchedHitVector)
			<< " , " << this->CountHitsByType(geo::kW,matchedHitVector)
			<< ")" << std::endl;
	    }      
	}
    }

}


DEFINE_ART_MODULE(nmspc::MyPandoraAnalyzer)
